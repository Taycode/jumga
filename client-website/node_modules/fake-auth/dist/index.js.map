{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["import { Base64 } from \"js-base64\";\n\n// Delay to mimic slower network requests\nconst RESPONSE_DELAY = 200;\n// Can increment to prevent old storage data from being used\nconst STORAGE_VERSION = \"fa5\";\n// Function to generate a fake JWT token\nconst generateToken = (data) => Base64.encode(JSON.stringify(data));\n// Function to generate user uid\nconst generateUid = () => String(Math.floor(Math.random() * 10000));\n\nexport default {\n  onChangeCallback: null,\n\n  getCurrentUser: function () {\n    const token = storeGet(\"access-token\");\n    return getAuth(token).then((auth) => auth.user);\n  },\n\n  signup: function (email, password) {\n    return getAuthByEmail(email).then((auth) => {\n      // Throw error if email is already in use\n      if (auth) {\n        throw new CustomError(\n          \"auth/email-already-in-use\",\n          \"Email is already in use\"\n        );\n      }\n\n      // Create auth object\n      const user = { uid: generateUid(), email, password };\n      const newAuth = { user, token: generateToken(user) };\n      // Store auth object and signin user\n      return addAuth(newAuth).then(() => {\n        this.changeAccessToken(newAuth.token);\n        return newAuth;\n      });\n    });\n  },\n\n  signin: function (email, password) {\n    return getAuthByEmail(email).then((auth) => {\n      // If user found then check password\n      if (auth) {\n        // If password match singin user otherwise throw error\n        if (auth.user.password === password) {\n          this.changeAccessToken(auth.token);\n          return auth;\n        } else {\n          throw new CustomError(\"auth/wrong-password\", \"Password is wrong\");\n        }\n      } else {\n        // If user not found then throw error\n        throw new CustomError(\n          \"auth/user-not-found\",\n          \"Email does not have an account\"\n        );\n      }\n    });\n  },\n\n  signinWithProvider: function (provider) {\n    return getAuthByProvider(provider).then((auth) => {\n      this.changeAccessToken(auth.token);\n      return auth;\n    });\n  },\n\n  signout: async function () {\n    // Signout user\n    this.changeAccessToken(null);\n    return Promise.resolve();\n  },\n\n  onChange: function (cb) {\n    // Store callback function so we can also call within\n    // setAccessToken(). Necessary because storage event listener\n    // only fires when local storage is changed by another tab.\n    this.onChangeCallback = cb;\n\n    const handleTokenChange = (token) => {\n      getAuth(token).then((auth) => {\n        this.onChangeCallback(auth || false);\n      });\n    };\n\n    const listener = window.addEventListener(\n      \"storage\",\n      ({ key, newValue }) => {\n        if (key === \"access-token\") {\n          handleTokenChange(JSON.parse(newValue));\n        }\n      },\n      false\n    );\n\n    const accessToken = storeGet(\"access-token\");\n    handleTokenChange(accessToken);\n\n    // Return an unsubscribe function so consumer\n    // can unsubscribe when needed.\n    return () => {\n      window.removeEventListener(\"storage\", listener);\n    };\n  },\n\n  sendPasswordResetEmail: function (email) {\n    // Get the user token for the email address and use as password reset code.\n    // A real auth service would do this server-side and email\n    // the code to the provided email address.\n    // For testing we save the reset code to local storage and\n    // read in subsequent confirmPasswordReset() call.\n    return getAuthByEmail(email).then((auth) => {\n      if (auth) {\n        storeSet(\"auth-pass-reset-code\", auth.token);\n        console.log(\"Your one-time use password reset code:\", auth.token);\n        throw new CustomError(\n          \"auth/cannot-send-email\",\n          `You're using Fake Auth, which cannot send password reset emails. These emails normally contain a link to your site with a special reset code. But worry not! Fake Auth has stored the reset code locally in your browser so you can simply go to your change password page now and choose a new password. This enables you to fully test your password reset flow and error states without involving emails.`\n        );\n      } else {\n        throw new CustomError(\n          \"auth/user-not-found\",\n          \"Email does not have an account\"\n        );\n      }\n    });\n  },\n\n  confirmPasswordReset: function (password, code) {\n    let resetCode;\n    // If code was passed in\n    if (code) {\n      resetCode = code;\n    } else {\n      // Otherwise grab the code from local storage\n      resetCode = storeGet(\"auth-pass-reset-code\");\n      // Remove code from storage so it's one-time use.\n      storeRemove(\"auth-pass-reset-code\");\n    }\n\n    return updateAuth(resetCode, { password }).then((updatedAuth) => {\n      if (updatedAuth) {\n        return true;\n      } else {\n        throw new CustomError(\n          \"auth/invalid-action-code\",\n          \"Invalid password update code\"\n        );\n      }\n    });\n  },\n\n  updateEmail: function (email) {\n    return updateAuthForCurrentUser({ email }).then((updatedAuth) => {\n      return updatedAuth.user;\n    });\n  },\n\n  updatePassword: function (password) {\n    return updateAuthForCurrentUser({ password }).then((updatedAuth) => {\n      return updatedAuth.user;\n    });\n  },\n\n  updateProfile: function (data) {\n    return updateAuthForCurrentUser(data).then((updatedAuth) => {\n      return updatedAuth.user;\n    });\n  },\n\n  // Updates access token in storage and calls onChangeCallback()\n  changeAccessToken: function (accessToken) {\n    storeSet(\"access-token\", accessToken);\n    // If we have an onChangeCallback (set in this.onChange)\n    if (this.onChangeCallback) {\n      // Fetch user via accessToken and pass to callback\n      getAuth(accessToken).then((auth) => {\n        this.onChangeCallback(auth || false);\n      });\n    }\n  },\n\n  getAccessToken: function () {\n    return storeGet(\"access-token\");\n  },\n\n  // Used server-side to verify and decode access token\n  verifyAccessToken: function (accessToken) {\n    return JSON.parse(Base64.decode(accessToken));\n  },\n};\n\n/***** LOCAL DB *****/\n\nconst _getAll = () => storeGet(\"auth-db\", []);\nconst _setAll = (db) => storeSet(\"auth-db\", db);\n\nconst getAuth = (token) => {\n  return delay(() => _getAll().find((item) => item.token === token));\n};\n\nconst getAuthByEmail = (email) => {\n  return delay(() =>\n    _getAll().find((item) => {\n      return item.user.email === email;\n    })\n  );\n};\n\nconst addAuth = (auth) => {\n  return delay(() => {\n    const all = _getAll();\n    all.push(auth);\n    _setAll(all);\n  });\n};\n\nconst updateAuthForCurrentUser = (userData) => {\n  const accessToken = storeGet(\"access-token\");\n  if (!accessToken) {\n    throw new CustomError(\n      \"auth/not-signed-in\",\n      `You must be signed in to perform this action`\n    );\n  }\n\n  return updateAuth(accessToken, userData);\n};\n\nconst updateAuth = (token, userData = {}) => {\n  return delay(() => {\n    const all = _getAll();\n    const index = all.findIndex((item) => item.token === token);\n\n    if (index !== -1) {\n      all[index] = {\n        ...all[index],\n        user: {\n          ...all[index].user,\n          ...userData,\n        },\n      };\n\n      _setAll(all);\n      return all[index];\n    } else {\n      return false;\n    }\n  });\n};\n\nconst getAuthByProvider = (provider) => {\n  // Normally there would be an actual OAuth flow here that returns\n  // the user's email address and provider data.\n  const emailFromOauth = \"demo@gmail.com\";\n  // First ensure user with above email exists in db\n  initializeDb();\n\n  return getAuthByEmail(emailFromOauth).then((auth) => {\n    return {\n      ...auth,\n      user: {\n        ...auth.user,\n        // Include provider in user object\n        // TODO: Persist this to storage\n        provider: provider,\n      },\n    };\n  });\n};\n\n/***** HELPERS *****/\n\nfunction storeGet(key, defaultValue = null) {\n  const value = window.localStorage.getItem(`${key}-${STORAGE_VERSION}`);\n  return value ? JSON.parse(value) : defaultValue;\n}\n\nfunction storeSet(key, value) {\n  window.localStorage.setItem(\n    `${key}-${STORAGE_VERSION}`,\n    JSON.stringify(value)\n  );\n}\n\nfunction storeRemove(key) {\n  window.localStorage.removeItem(`${key}-${STORAGE_VERSION}`);\n}\n\nconst delay = (cb) => {\n  return new Promise((resolve) =>\n    setTimeout(() => {\n      resolve(cb());\n    }, RESPONSE_DELAY)\n  );\n};\n\nfunction CustomError(code, message) {\n  const error = new Error(message);\n  error.code = code;\n  return error;\n}\n\nCustomError.prototype = Object.create(Error.prototype);\n\n/***** INITIALIZE *****/\n\nconst initialUser = {\n  uid: generateUid(),\n  email: \"demo@gmail.com\",\n  password: \"demo\",\n};\n\nconst initialAuth = {\n  user: initialUser,\n  token: generateToken(initialUser),\n};\n\nfunction initializeDb() {\n  // See if initialUser is in db\n  // _getAll() will return an empty array if db is not in local storage yet\n  const found = _getAll().find((item) => {\n    return item.user.email === initialUser.email;\n  });\n\n  // If initialUser not in db then add them\n  // This will create the db in local storage if it previously didn't exist\n  if (!found) {\n    const all = _getAll();\n    all.push(initialAuth);\n    _setAll(all);\n  }\n}\n\n// Initialize db if client-side\nif (typeof window !== \"undefined\") {\n  initializeDb();\n}\n"],"names":["generateToken","data","Base64","encode","JSON","stringify","generateUid","String","Math","floor","random","onChangeCallback","getCurrentUser","token","storeGet","getAuth","then","auth","user","signup","email","password","getAuthByEmail","CustomError","uid","newAuth","addAuth","_this","changeAccessToken","signin","_this2","signinWithProvider","provider","getAuthByProvider","_this3","signout","this","Promise","resolve","onChange","cb","handleTokenChange","_this6","listener","window","addEventListener","key","parse","newValue","accessToken","removeEventListener","sendPasswordResetEmail","storeSet","console","log","confirmPasswordReset","code","resetCode","localStorage","removeItem","updateAuth","updatedAuth","updateEmail","updateAuthForCurrentUser","updatePassword","updateProfile","_this7","getAccessToken","verifyAccessToken","decode","_getAll","_setAll","db","delay","find","item","all","push","userData","index","findIndex","initializeDb","defaultValue","value","getItem","setItem","setTimeout","message","error","Error","prototype","Object","create","initialUser","initialAuth"],"mappings":"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"}