(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.ReactQuery = {}, global.React));
}(this, (function (exports, React) { 'use strict';

  React = React && Object.prototype.hasOwnProperty.call(React, 'default') ? React['default'] : React;

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  (function (QueryStatus) {
    QueryStatus["Idle"] = "idle";
    QueryStatus["Loading"] = "loading";
    QueryStatus["Error"] = "error";
    QueryStatus["Success"] = "success";
  })(exports.QueryStatus || (exports.QueryStatus = {}));

  var CancelledError = function CancelledError() {}; // UTILS

  var _uid = 0;
  var uid = function uid() {
    return _uid++;
  };
  var isServer = typeof window === 'undefined';

  function noop() {
    return void 0;
  }

  var Console = console || {
    error: noop,
    warn: noop,
    log: noop
  };
  function setConsole(c) {
    Console = c;
  }
  function functionalUpdate(updater, input) {
    return typeof updater === 'function' ? updater(input) : updater;
  }

  function stableStringifyReplacer(_key, value) {
    if (typeof value === 'function') {
      throw new Error('Cannot stringify non JSON value');
    }

    if (isObject(value)) {
      return Object.keys(value).sort().reduce(function (result, key) {
        result[key] = value[key];
        return result;
      }, {});
    }

    return value;
  }

  function stableStringify(value) {
    return JSON.stringify(value, stableStringifyReplacer);
  }
  function deepIncludes(a, b) {
    if (a === b) {
      return true;
    }

    if (typeof a !== typeof b) {
      return false;
    }

    if (typeof a === 'object') {
      return !Object.keys(b).some(function (key) {
        return !deepIncludes(a[key], b[key]);
      });
    }

    return false;
  }
  function isDocumentVisible() {
    // document global can be unavailable in react native
    if (typeof document === 'undefined') {
      return true;
    }

    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);
  }
  function isOnline() {
    return navigator.onLine === undefined || navigator.onLine;
  }
  function getQueryArgs(args) {
    var queryKey;
    var queryFn;
    var config;
    var options;

    if (isObject(args[0])) {
      queryKey = args[0].queryKey;
      queryFn = args[0].queryFn;
      config = args[0].config;
      options = args[1];
    } else if (isObject(args[1])) {
      queryKey = args[0];
      config = args[1];
      options = args[2];
    } else {
      queryKey = args[0];
      queryFn = args[1];
      config = args[2];
      options = args[3];
    }

    config = config ? _extends({
      queryKey: queryKey
    }, config) : {
      queryKey: queryKey
    };

    if (queryFn) {
      config = _extends({}, config, {
        queryFn: queryFn
      });
    }

    return [queryKey, config, options];
  }
  /**
   * This function returns `a` if `b` is deeply equal.
   * If not, it will replace any deeply equal children of `b` with those of `a`.
   * This can be used for structural sharing between JSON values for example.
   */

  function replaceEqualDeep(a, b) {
    if (a === b) {
      return a;
    }

    var array = Array.isArray(a) && Array.isArray(b);

    if (array || isPlainObject(a) && isPlainObject(b)) {
      var aSize = array ? a.length : Object.keys(a).length;
      var bItems = array ? b : Object.keys(b);
      var bSize = bItems.length;
      var copy = array ? [] : {};
      var equalItems = 0;

      for (var i = 0; i < bSize; i++) {
        var key = array ? i : bItems[i];
        copy[key] = replaceEqualDeep(a[key], b[key]);

        if (copy[key] === a[key]) {
          equalItems++;
        }
      }

      return aSize === bSize && equalItems === aSize ? a : copy;
    }

    return b;
  }
  function isObject(a) {
    return a && typeof a === 'object' && !Array.isArray(a);
  } // Copied from: https://github.com/jonschlinkert/is-plain-object

  function isPlainObject(o) {
    if (!hasObjectPrototype(o)) {
      return false;
    } // If has modified constructor


    var ctor = o.constructor;

    if (typeof ctor === 'undefined') {
      return true;
    } // If has modified prototype


    var prot = ctor.prototype;

    if (!hasObjectPrototype(prot)) {
      return false;
    } // If constructor does not have an Object-specific method


    if (!prot.hasOwnProperty('isPrototypeOf')) {
      return false;
    } // Most likely a plain Object


    return true;
  }

  function hasObjectPrototype(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
  }

  function isCancelable(value) {
    return typeof (value == null ? void 0 : value.cancel) === 'function';
  }
  function isError(value) {
    return value instanceof Error;
  }
  function isCancelledError(value) {
    return value instanceof CancelledError;
  }
  function sleep(timeout) {
    return new Promise(function (resolve) {
      setTimeout(resolve, timeout);
    });
  }
  function getStatusProps(status) {
    return {
      status: status,
      isLoading: status === exports.QueryStatus.Loading,
      isSuccess: status === exports.QueryStatus.Success,
      isError: status === exports.QueryStatus.Error,
      isIdle: status === exports.QueryStatus.Idle
    };
  }
  function createSetHandler(fn) {
    var removePreviousHandler;
    return function (callback) {
      // Unsub the old handler
      if (removePreviousHandler) {
        removePreviousHandler();
      } // Sub the new handler


      removePreviousHandler = callback(fn);
    };
  }

  // CONFIG
  var defaultQueryKeySerializerFn = function defaultQueryKeySerializerFn(queryKey) {
    try {
      var arrayQueryKey = Array.isArray(queryKey) ? queryKey : [queryKey];
      var queryHash = stableStringify(arrayQueryKey);
      arrayQueryKey = JSON.parse(queryHash);
      return [queryHash, arrayQueryKey];
    } catch (_unused) {
      throw new Error('A valid query key is required!');
    }
  };
  /**
   * Config merging strategy
   *
   * When using hooks the config will be merged in the following order:
   *
   * 1. These defaults.
   * 2. Defaults from the hook query cache.
   * 3. Combined defaults from any config providers in the tree.
   * 4. Query/mutation config provided to the hook.
   *
   * When using a query cache directly the config will be merged in the following order:
   *
   * 1. These defaults.
   * 2. Defaults from the query cache.
   * 3. Query/mutation config provided to the query cache method.
   */

  var DEFAULT_CONFIG = {
    queries: {
      queryKeySerializerFn: defaultQueryKeySerializerFn,
      enabled: true,
      retry: 3,
      retryDelay: function retryDelay(attemptIndex) {
        return Math.min(1000 * Math.pow(2, attemptIndex), 30000);
      },
      staleTime: 0,
      cacheTime: 5 * 60 * 1000,
      refetchOnWindowFocus: true,
      refetchOnReconnect: true,
      refetchOnMount: true,
      structuralSharing: true
    }
  };
  function mergeReactQueryConfigs(a, b) {
    return {
      shared: _extends({}, a.shared, b.shared),
      queries: _extends({}, a.queries, b.queries),
      mutations: _extends({}, a.mutations, b.mutations)
    };
  }
  function getDefaultedQueryConfig(queryCacheConfig, contextConfig, config, configOverrides) {
    return _extends({}, DEFAULT_CONFIG.shared, DEFAULT_CONFIG.queries, queryCacheConfig == null ? void 0 : queryCacheConfig.shared, queryCacheConfig == null ? void 0 : queryCacheConfig.queries, contextConfig == null ? void 0 : contextConfig.shared, contextConfig == null ? void 0 : contextConfig.queries, config, configOverrides);
  }
  function getDefaultedMutationConfig(queryCacheConfig, contextConfig, config, configOverrides) {
    return _extends({}, DEFAULT_CONFIG.shared, DEFAULT_CONFIG.mutations, queryCacheConfig == null ? void 0 : queryCacheConfig.shared, queryCacheConfig == null ? void 0 : queryCacheConfig.mutations, contextConfig == null ? void 0 : contextConfig.shared, contextConfig == null ? void 0 : contextConfig.mutations, config, configOverrides);
  }

  function _await(value, then, direct) {
    if (direct) {
      return then ? then(value) : value;
    }

    if (!value || !value.then) {
      value = Promise.resolve(value);
    }

    return then ? value.then(then) : value;
  }

  function _catch(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  }

  var QueryObserver = /*#__PURE__*/function () {
    function QueryObserver(config) {
      this.config = config; // Bind exposed methods

      this.clear = this.clear.bind(this);
      this.refetch = this.refetch.bind(this);
      this.fetchMore = this.fetchMore.bind(this); // Subscribe to the query

      this.updateQuery();
    }

    var _proto = QueryObserver.prototype;

    _proto.subscribe = function subscribe(listener) {
      this.started = true;
      this.updateListener = listener;
      this.currentQuery.subscribeObserver(this);
      this.optionalFetch();
      this.updateRefetchInterval();
      return this.unsubscribe.bind(this);
    };

    _proto.unsubscribe = function unsubscribe() {
      this.started = false;
      this.updateListener = undefined;
      this.clearRefetchInterval();
      this.currentQuery.unsubscribeObserver(this);
    };

    _proto.updateConfig = function updateConfig(config) {
      var prevConfig = this.config;
      this.config = config;
      var updated = this.updateQuery(); // Take no further actions if the observer did not start yet

      if (!this.started) {
        return;
      } // If we subscribed to a new query, optionally fetch and update refetch


      if (updated) {
        this.optionalFetch();
        this.updateRefetchInterval();
        return;
      } // Optionally fetch if the query became enabled


      if (config.enabled && !prevConfig.enabled) {
        this.optionalFetch();
      } // Update refetch interval if needed


      if (config.enabled !== prevConfig.enabled || config.refetchInterval !== prevConfig.refetchInterval || config.refetchIntervalInBackground !== prevConfig.refetchIntervalInBackground) {
        this.updateRefetchInterval();
      }
    };

    _proto.getCurrentResult = function getCurrentResult() {
      return this.currentResult;
    };

    _proto.clear = function clear() {
      return this.currentQuery.clear();
    };

    _proto.refetch = function refetch(options) {
      try {
        var _this2 = this;

        _this2.currentQuery.updateConfig(_this2.config);

        return _this2.currentQuery.refetch(options);
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.fetchMore = function fetchMore(fetchMoreVariable, options) {
      try {
        var _this4 = this;

        _this4.currentQuery.updateConfig(_this4.config);

        return _this4.currentQuery.fetchMore(fetchMoreVariable, options);
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.fetch = function fetch() {
      try {
        var _this6 = this;

        _this6.currentQuery.updateConfig(_this6.config);

        return _catch(function () {
          return _await(_this6.currentQuery.fetch());
        }, function () {
          return undefined;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.optionalFetch = function optionalFetch() {
      if (this.config.enabled && // Don't auto refetch if disabled
      !(this.config.suspense && this.currentResult.isFetched) && // Don't refetch if in suspense mode and the data is already fetched
      this.currentResult.isStale && ( // Only refetch if stale
      this.config.refetchOnMount || this.currentQuery.observers.length === 1)) {
        this.fetch();
      }
    };

    _proto.updateRefetchInterval = function updateRefetchInterval() {
      var _this7 = this;

      if (isServer) {
        return;
      }

      this.clearRefetchInterval();

      if (!this.config.enabled || !this.config.refetchInterval || this.config.refetchInterval < 0 || this.config.refetchInterval === Infinity) {
        return;
      }

      this.refetchIntervalId = setInterval(function () {
        if (_this7.config.refetchIntervalInBackground || isDocumentVisible()) {
          _this7.fetch();
        }
      }, this.config.refetchInterval);
    };

    _proto.clearRefetchInterval = function clearRefetchInterval() {
      if (this.refetchIntervalId) {
        clearInterval(this.refetchIntervalId);
        this.refetchIntervalId = undefined;
      }
    };

    _proto.createResult = function createResult() {
      var currentQuery = this.currentQuery,
          previousResult = this.previousResult,
          config = this.config;
      var _currentQuery$state = currentQuery.state,
          canFetchMore = _currentQuery$state.canFetchMore,
          error = _currentQuery$state.error,
          failureCount = _currentQuery$state.failureCount,
          isFetched = _currentQuery$state.isFetched,
          isFetching = _currentQuery$state.isFetching,
          isFetchingMore = _currentQuery$state.isFetchingMore,
          isLoading = _currentQuery$state.isLoading,
          isStale = _currentQuery$state.isStale;
      var _currentQuery$state2 = currentQuery.state,
          data = _currentQuery$state2.data,
          status = _currentQuery$state2.status,
          updatedAt = _currentQuery$state2.updatedAt; // Keep previous data if needed

      if (config.keepPreviousData && isLoading && (previousResult == null ? void 0 : previousResult.isSuccess)) {
        data = previousResult.data;
        updatedAt = previousResult.updatedAt;
        status = previousResult.status;
      }

      return _extends({}, getStatusProps(status), {
        canFetchMore: canFetchMore,
        clear: this.clear,
        data: data,
        error: error,
        failureCount: failureCount,
        fetchMore: this.fetchMore,
        isFetched: isFetched,
        isFetching: isFetching,
        isFetchingMore: isFetchingMore,
        isStale: isStale,
        query: currentQuery,
        refetch: this.refetch,
        updatedAt: updatedAt
      });
    };

    _proto.updateQuery = function updateQuery() {
      var prevQuery = this.currentQuery; // Remove the initial data when there is an existing query
      // because this data should not be used for a new query

      var config = prevQuery ? _extends({}, this.config, {
        initialData: undefined
      }) : this.config;
      var newQuery = config.queryCache.buildQuery(config.queryKey, config);

      if (newQuery === prevQuery) {
        return false;
      }

      newQuery.activateTimeouts();
      this.previousResult = this.currentResult;
      this.currentQuery = newQuery;
      this.currentResult = this.createResult();

      if (this.started) {
        prevQuery == null ? void 0 : prevQuery.unsubscribeObserver(this);
        this.currentQuery.subscribeObserver(this);
      }

      return true;
    };

    _proto.onQueryUpdate = function onQueryUpdate(_state, action) {
      var _this$updateListener;

      this.currentResult = this.createResult();
      var _this$currentResult = this.currentResult,
          data = _this$currentResult.data,
          error = _this$currentResult.error,
          isSuccess = _this$currentResult.isSuccess,
          isError = _this$currentResult.isError;

      if (action.type === 'Success' && isSuccess) {
        var _this$config$onSucces, _this$config, _this$config$onSettle, _this$config2;

        (_this$config$onSucces = (_this$config = this.config).onSuccess) == null ? void 0 : _this$config$onSucces.call(_this$config, data);
        (_this$config$onSettle = (_this$config2 = this.config).onSettled) == null ? void 0 : _this$config$onSettle.call(_this$config2, data, null);
        this.updateRefetchInterval();
      } else if (action.type === 'Error' && isError) {
        var _this$config$onError, _this$config3, _this$config$onSettle2, _this$config4;

        (_this$config$onError = (_this$config3 = this.config).onError) == null ? void 0 : _this$config$onError.call(_this$config3, error);
        (_this$config$onSettle2 = (_this$config4 = this.config).onSettled) == null ? void 0 : _this$config$onSettle2.call(_this$config4, undefined, error);
        this.updateRefetchInterval();
      }

      (_this$updateListener = this.updateListener) == null ? void 0 : _this$updateListener.call(this, this.currentResult);
    };

    return QueryObserver;
  }();

  function _await$1(value, then, direct) {
    if (direct) {
      return then ? then(value) : value;
    }

    if (!value || !value.then) {
      value = Promise.resolve(value);
    }

    return then ? value.then(then) : value;
  }

  function _catch$1(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  }

  function _empty() {}

  function _awaitIgnored(value, direct) {
    if (!direct) {
      return value && value.then ? value.then(_empty) : Promise.resolve();
    }
  }

  function _invoke(body, then) {
    var result = body();

    if (result && result.then) {
      return result.then(then);
    }

    return then(result);
  }

  function _async(f) {
    return function () {
      for (var args = [], i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      try {
        return Promise.resolve(f.apply(this, args));
      } catch (e) {
        return Promise.reject(e);
      }
    };
  }

  var ActionType;

  (function (ActionType) {
    ActionType["Failed"] = "Failed";
    ActionType["MarkStale"] = "MarkStale";
    ActionType["Fetch"] = "Fetch";
    ActionType["Success"] = "Success";
    ActionType["Error"] = "Error";
  })(ActionType || (ActionType = {}));

  // CLASS
  var Query = /*#__PURE__*/function () {
    function Query(init) {
      this.config = init.config;
      this.queryCache = init.queryCache;
      this.queryKey = init.queryKey;
      this.queryHash = init.queryHash;
      this.notifyGlobalListeners = init.notifyGlobalListeners;
      this.observers = [];
      this.state = getDefaultState(init.config);
      this.enableTimeouts = false;
    }

    var _proto = Query.prototype;

    _proto.activateTimeouts = function activateTimeouts() {
      this.enableTimeouts = true;
      this.rescheduleStaleTimeout();
      this.rescheduleGarbageCollection();
    };

    _proto.updateConfig = function updateConfig(config) {
      this.config = config;
    };

    _proto.dispatch = function dispatch(action) {
      var _this = this;

      this.state = queryReducer(this.state, action);
      this.observers.forEach(function (d) {
        return d.onQueryUpdate(_this.state, action);
      });
      this.notifyGlobalListeners(this);
    };

    _proto.rescheduleStaleTimeout = function rescheduleStaleTimeout() {
      var _this2 = this;

      if (isServer) {
        return;
      }

      this.clearStaleTimeout();

      if (!this.enableTimeouts || this.state.isStale || this.state.status !== exports.QueryStatus.Success || this.config.staleTime === Infinity) {
        return;
      }

      var staleTime = this.config.staleTime || 0;
      var timeout = staleTime;

      if (this.state.updatedAt) {
        var timeElapsed = Date.now() - this.state.updatedAt;
        var timeUntilStale = staleTime - timeElapsed;
        timeout = Math.max(timeUntilStale, 0);
      }

      this.staleTimeout = setTimeout(function () {
        _this2.invalidate();
      }, timeout);
    };

    _proto.invalidate = function invalidate() {
      this.clearStaleTimeout();

      if (this.state.isStale) {
        return;
      }

      this.dispatch({
        type: ActionType.MarkStale
      });
    };

    _proto.rescheduleGarbageCollection = function rescheduleGarbageCollection() {
      var _this3 = this;

      if (isServer) {
        return;
      }

      this.clearCacheTimeout();

      if (!this.enableTimeouts || this.config.cacheTime === Infinity || this.observers.length > 0) {
        return;
      }

      this.cacheTimeout = setTimeout(function () {
        _this3.clear();
      }, this.config.cacheTime);
    };

    _proto.refetch = function refetch(options) {
      try {
        var _this5 = this;

        return _catch$1(function () {
          return _await$1(_this5.fetch());
        }, function (error) {
          if ((options == null ? void 0 : options.throwOnError) === true) {
            throw error;
          }

          return undefined;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.cancel = function cancel() {
      var _this$cancelFetch;

      (_this$cancelFetch = this.cancelFetch) == null ? void 0 : _this$cancelFetch.call(this);
    };

    _proto.continue = function _continue() {
      var _this$continueFetch;

      (_this$continueFetch = this.continueFetch) == null ? void 0 : _this$continueFetch.call(this);
    };

    _proto.clearTimersObservers = function clearTimersObservers() {
      this.observers.forEach(function (observer) {
        observer.clearRefetchInterval();
      });
    };

    _proto.clearStaleTimeout = function clearStaleTimeout() {
      if (this.staleTimeout) {
        clearTimeout(this.staleTimeout);
        this.staleTimeout = undefined;
      }
    };

    _proto.clearCacheTimeout = function clearCacheTimeout() {
      if (this.cacheTimeout) {
        clearTimeout(this.cacheTimeout);
        this.cacheTimeout = undefined;
      }
    };

    _proto.setData = function setData(updater) {
      var _this$config$isDataEq, _this$config;

      var prevData = this.state.data; // Get the new data

      var data = functionalUpdate(updater, prevData); // Structurally share data between prev and new data if needed

      if (this.config.structuralSharing) {
        data = replaceEqualDeep(prevData, data);
      } // Use prev data if an isDataEqual function is defined and returns `true`


      if ((_this$config$isDataEq = (_this$config = this.config).isDataEqual) == null ? void 0 : _this$config$isDataEq.call(_this$config, prevData, data)) {
        data = prevData;
      }

      var isStale = this.config.staleTime === 0; // Try to determine if more data can be fetched

      var canFetchMore = hasMorePages(this.config, data); // Set data and mark it as cached

      this.dispatch({
        type: ActionType.Success,
        data: data,
        isStale: isStale,
        canFetchMore: canFetchMore
      });
      this.rescheduleStaleTimeout();
    };

    _proto.clear = function clear() {
      this.clearStaleTimeout();
      this.clearCacheTimeout();
      this.clearTimersObservers();
      this.cancel();
      delete this.queryCache.queries[this.queryHash];
      this.notifyGlobalListeners(this);
    };

    _proto.isEnabled = function isEnabled() {
      return this.observers.some(function (observer) {
        return observer.config.enabled;
      });
    };

    _proto.onWindowFocus = function onWindowFocus() {
      if (this.state.isStale && this.observers.some(function (observer) {
        return observer.config.enabled && observer.config.refetchOnWindowFocus;
      })) {
        this.fetch();
      }

      this.continue();
    };

    _proto.onOnline = function onOnline() {
      if (this.state.isStale && this.observers.some(function (observer) {
        return observer.config.enabled && observer.config.refetchOnReconnect;
      })) {
        this.fetch();
      }

      this.continue();
    };

    _proto.subscribe = function subscribe(listener) {
      var observer = new QueryObserver(_extends({
        queryCache: this.queryCache,
        queryKey: this.queryKey
      }, this.config));
      observer.subscribe(listener);
      return observer;
    };

    _proto.subscribeObserver = function subscribeObserver(observer) {
      this.observers.push(observer); // Stop the query from being garbage collected

      this.clearCacheTimeout();
    };

    _proto.unsubscribeObserver = function unsubscribeObserver(observer) {
      this.observers = this.observers.filter(function (x) {
        return x !== observer;
      });

      if (!this.observers.length) {
        // If the transport layer does not support cancellation
        // we'll let the query continue so the result can be cached
        if (this.isTransportCancelable) {
          this.cancel();
        }
      }

      this.rescheduleGarbageCollection();
    };

    _proto.tryFetchData = function tryFetchData(config, fn) {
      try {
        var _this7 = this;

        return new Promise(function (outerResolve, outerReject) {
          var resolved = false;
          var continueLoop;
          var cancelTransport;

          var done = function done() {
            resolved = true;
            delete _this7.cancelFetch;
            delete _this7.continueFetch;
            delete _this7.isTransportCancelable; // End loop if currently paused

            continueLoop == null ? void 0 : continueLoop();
          };

          var resolve = function resolve(value) {
            done();
            outerResolve(value);
          };

          var reject = function reject(value) {
            done();
            outerReject(value);
          }; // Create callback to cancel this fetch


          _this7.cancelFetch = function () {
            reject(new CancelledError());

            try {
              cancelTransport == null ? void 0 : cancelTransport();
            } catch (_unused) {}
          }; // Create callback to continue this fetch


          _this7.continueFetch = function () {
            continueLoop == null ? void 0 : continueLoop();
          }; // Create loop function


          var run = _async(function () {
            return _catch$1(function () {
              // Execute query
              var promiseOrValue = fn(); // Check if the transport layer support cancellation

              if (isCancelable(promiseOrValue)) {
                cancelTransport = function cancelTransport() {
                  promiseOrValue.cancel();
                };

                _this7.isTransportCancelable = true;
              } // Await data


              return _await$1(promiseOrValue, function (_promiseOrValue) {
                resolve(_promiseOrValue);
              });
            }, function (error) {
              // Stop if the fetch is already resolved
              if (resolved) {
                return;
              } // Do we need to retry the request?


              var failureCount = _this7.state.failureCount;
              var retry = config.retry,
                  retryDelay = config.retryDelay;
              var shouldRetry = retry === true || failureCount < retry || typeof retry === 'function' && retry(failureCount, error);

              if (!shouldRetry) {
                // We are done if the query does not need to be retried
                reject(error);
                return;
              } // Increase the failureCount


              _this7.dispatch({
                type: ActionType.Failed
              }); // Delay


              return _await$1(sleep(functionalUpdate(retryDelay, failureCount) || 0), function () {
                // Pause retry if the document is not visible or when the device is offline
                return _invoke(function () {
                  if (!isDocumentVisible() || !isOnline()) {
                    return _awaitIgnored(new Promise(function (continueResolve) {
                      continueLoop = continueResolve;
                    }));
                  }
                }, function () {
                  if (!resolved) {
                    run();
                  }
                }); // Try again if not resolved yet
              });
            });
          }); // Start loop


          run();
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.fetch = function fetch(options) {
      try {
        var _this9 = this;

        // If we are already fetching, return current promise
        if (_this9.promise) {
          return _this9.promise;
        } // Store reference to the config that initiated this fetch


        var config = _this9.config; // Check if there is a query function

        if (!config.queryFn) {
          return;
        } // Get the query function params


        var filter = config.queryFnParamsFilter;
        var params = filter ? filter(_this9.queryKey) : _this9.queryKey;
        _this9.promise = _async(function () {
          return _catch$1(function () {
            var data;
            return _invoke(function () {
              if (config.infinite) {
                return _await$1(_this9.startInfiniteFetch(config, params, options), function (_this9$startInfiniteF) {
                  data = _this9$startInfiniteF;
                });
              } else {
                return _await$1(_this9.startFetch(config, params, options), function (_this9$startFetch) {
                  data = _this9$startFetch;
                });
              }
            }, function () {
              // Set success state
              _this9.setData(data); // Cleanup


              delete _this9.promise; // Return data

              return data;
            });
          }, function (error) {
            // Set error state
            _this9.dispatch({
              type: ActionType.Error,
              error: error
            }); // Log error


            if (!isCancelledError(error)) {
              Console.error(error);
            } // Cleanup


            delete _this9.promise; // Propagate error

            throw error;
          });
        })();
        return _this9.promise;
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.startFetch = function startFetch(config, params, _options) {
      try {
        var _this11 = this;

        // Create function to fetch the data
        var fetchData = function fetchData() {
          return config.queryFn.apply(void 0, params);
        }; // Set to fetching state if not already in it


        if (!_this11.state.isFetching) {
          _this11.dispatch({
            type: ActionType.Fetch
          });
        } // Try to fetch the data


        return _this11.tryFetchData(config, fetchData);
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.startInfiniteFetch = function startInfiniteFetch(config, params, options) {
      try {
        var _this13 = this;

        var fetchMore = options == null ? void 0 : options.fetchMore;

        var _ref = fetchMore || {},
            previous = _ref.previous,
            fetchMoreVariable = _ref.fetchMoreVariable;

        var isFetchingMore = fetchMore ? previous ? 'previous' : 'next' : false;
        var prevPages = _this13.state.data || []; // Create function to fetch a page

        var fetchPage = _async(function (pages, prepend, cursor) {
          var lastPage = getLastPage(pages, prepend);

          if (typeof cursor === 'undefined' && typeof lastPage !== 'undefined' && config.getFetchMore) {
            cursor = config.getFetchMore(lastPage, pages);
          }

          return _await$1(config.queryFn.apply(void 0, params.concat([cursor])), function (page) {
            return prepend ? [page].concat(pages) : [].concat(pages, [page]);
          });
        }); // Create function to fetch the data


        var fetchData = function fetchData() {
          if (isFetchingMore) {
            return fetchPage(prevPages, previous, fetchMoreVariable);
          } else if (!prevPages.length) {
            return fetchPage([]);
          } else {
            var promise = fetchPage([]);

            for (var i = 1; i < prevPages.length; i++) {
              promise = promise.then(fetchPage);
            }

            return promise;
          }
        }; // Set to fetching state if not already in it


        if (!_this13.state.isFetching) {
          _this13.dispatch({
            type: ActionType.Fetch,
            isFetchingMore: isFetchingMore
          });
        } // Try to get the data


        return _this13.tryFetchData(config, fetchData);
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.fetchMore = function fetchMore(fetchMoreVariable, options) {
      return this.fetch({
        fetchMore: {
          fetchMoreVariable: fetchMoreVariable,
          previous: (options == null ? void 0 : options.previous) || false
        }
      });
    };

    return Query;
  }();

  function getLastPage(pages, previous) {
    return previous ? pages[0] : pages[pages.length - 1];
  }

  function hasMorePages(config, pages, previous) {
    if (config.infinite && config.getFetchMore && Array.isArray(pages)) {
      return Boolean(config.getFetchMore(getLastPage(pages, previous), pages));
    }

    return undefined;
  }

  function getDefaultState(config) {
    var _config$initialStale;

    var initialData = typeof config.initialData === 'function' ? config.initialData() : config.initialData;
    var hasInitialData = typeof initialData !== 'undefined';
    var isStale = !config.enabled || (typeof config.initialStale === 'function' ? config.initialStale() : (_config$initialStale = config.initialStale) != null ? _config$initialStale : !hasInitialData);
    var initialStatus = hasInitialData ? exports.QueryStatus.Success : config.enabled ? exports.QueryStatus.Loading : exports.QueryStatus.Idle;
    return _extends({}, getStatusProps(initialStatus), {
      error: null,
      isFetched: false,
      isFetching: initialStatus === exports.QueryStatus.Loading,
      isFetchingMore: false,
      failureCount: 0,
      isStale: isStale,
      data: initialData,
      updatedAt: hasInitialData ? Date.now() : 0,
      canFetchMore: hasMorePages(config, initialData)
    });
  }

  function queryReducer(state, action) {
    switch (action.type) {
      case ActionType.Failed:
        return _extends({}, state, {
          failureCount: state.failureCount + 1
        });

      case ActionType.MarkStale:
        return _extends({}, state, {
          isStale: true
        });

      case ActionType.Fetch:
        var status = typeof state.data !== 'undefined' ? exports.QueryStatus.Success : exports.QueryStatus.Loading;
        return _extends({}, state, getStatusProps(status), {
          isFetching: true,
          isFetchingMore: action.isFetchingMore || false,
          failureCount: 0
        });

      case ActionType.Success:
        return _extends({}, state, getStatusProps(exports.QueryStatus.Success), {
          data: action.data,
          error: null,
          isStale: action.isStale,
          isFetched: true,
          isFetching: false,
          isFetchingMore: false,
          canFetchMore: action.canFetchMore,
          updatedAt: Date.now(),
          failureCount: 0
        });

      case ActionType.Error:
        return _extends({}, state, getStatusProps(exports.QueryStatus.Error), {
          error: action.error,
          isFetched: true,
          isFetching: false,
          isFetchingMore: false,
          isStale: true,
          failureCount: state.failureCount + 1,
          throwInErrorBoundary: true
        });

      default:
        return state;
    }
  }

  // CLASS
  function _empty$1() {}

  function _awaitIgnored$1(value, direct) {
    if (!direct) {
      return value && value.then ? value.then(_empty$1) : Promise.resolve();
    }
  }

  function _catch$2(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  }

  function _invoke$1(body, then) {
    var result = body();

    if (result && result.then) {
      return result.then(then);
    }

    return then(result);
  }

  function _rethrow(thrown, value) {
    if (thrown) throw value;
    return value;
  }

  function _finallyRethrows(body, finalizer) {
    try {
      var result = body();
    } catch (e) {
      return finalizer(true, e);
    }

    if (result && result.then) {
      return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
    }

    return finalizer(false, result);
  }

  var QueryCache = /*#__PURE__*/function () {
    function QueryCache(config) {
      this.config = config || {}; // A frozen cache does not add new queries to the cache

      this.globalListeners = [];
      this.queries = {};
      this.isFetching = 0;
    }

    var _proto = QueryCache.prototype;

    _proto.notifyGlobalListeners = function notifyGlobalListeners(query) {
      var _this = this;

      this.isFetching = Object.values(this.queries).reduce(function (acc, query) {
        return query.state.isFetching ? acc + 1 : acc;
      }, 0);
      this.globalListeners.forEach(function (d) {
        return d(_this, query);
      });
    };

    _proto.getDefaultConfig = function getDefaultConfig() {
      return this.config.defaultConfig;
    };

    _proto.getDefaultedQueryConfig = function getDefaultedQueryConfig$1(config) {
      return getDefaultedQueryConfig(this.getDefaultConfig(), undefined, config, {
        queryCache: this
      });
    };

    _proto.subscribe = function subscribe(listener) {
      var _this2 = this;

      this.globalListeners.push(listener);
      return function () {
        _this2.globalListeners.splice(_this2.globalListeners.indexOf(listener), 1);
      };
    };

    _proto.clear = function clear(options) {
      Object.values(this.queries).forEach(function (query) {
        return query.clear();
      });
      this.queries = {};

      if (options == null ? void 0 : options.notify) {
        this.notifyGlobalListeners();
      }
    };

    _proto.getQueries = function getQueries(predicate, options) {
      if (predicate === true) {
        return Object.values(this.queries);
      }

      var predicateFn;

      if (typeof predicate === 'function') {
        predicateFn = predicate;
      } else {
        var _config = this.getDefaultedQueryConfig();

        var _ref = _config.queryKeySerializerFn(predicate),
            queryHash = _ref[0],
            _queryKey = _ref[1];

        predicateFn = function predicateFn(d) {
          return (options == null ? void 0 : options.exact) ? d.queryHash === queryHash : deepIncludes(d.queryKey, _queryKey);
        };
      }

      return Object.values(this.queries).filter(predicateFn);
    };

    _proto.getQuery = function getQuery(predicate) {
      return this.getQueries(predicate, {
        exact: true
      })[0];
    };

    _proto.getQueryData = function getQueryData(predicate) {
      var _this$getQuery;

      return (_this$getQuery = this.getQuery(predicate)) == null ? void 0 : _this$getQuery.state.data;
    };

    _proto.removeQueries = function removeQueries(predicate, options) {
      this.getQueries(predicate, options).forEach(function (query) {
        return query.clear();
      });
    };

    _proto.cancelQueries = function cancelQueries(predicate, options) {
      this.getQueries(predicate, options).forEach(function (query) {
        return query.cancel();
      });
    };

    _proto.invalidateQueries = function invalidateQueries(predicate, options) {
      try {
        var _this4 = this;

        var _ref2 = options || {},
            _ref2$refetchActive = _ref2.refetchActive,
            refetchActive = _ref2$refetchActive === void 0 ? true : _ref2$refetchActive,
            _ref2$refetchInactive = _ref2.refetchInactive,
            refetchInactive = _ref2$refetchInactive === void 0 ? false : _ref2$refetchInactive,
            throwOnError = _ref2.throwOnError;

        return _catch$2(function () {
          return _awaitIgnored$1(Promise.all(_this4.getQueries(predicate, options).map(function (query) {
            if (query.observers.length) {
              if (refetchActive && query.isEnabled()) {
                return query.fetch();
              }
            } else {
              if (refetchInactive) {
                return query.fetch();
              }
            }

            return query.invalidate();
          })));
        }, function (err) {
          if (throwOnError) {
            throw err;
          }
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.resetErrorBoundaries = function resetErrorBoundaries() {
      this.getQueries(true).forEach(function (query) {
        query.state.throwInErrorBoundary = false;
      });
    };

    _proto.buildQuery = function buildQuery(userQueryKey, queryConfig) {
      var _this5 = this;

      var config = this.getDefaultedQueryConfig(queryConfig);

      var _ref3 = config.queryKeySerializerFn(userQueryKey),
          queryHash = _ref3[0],
          queryKey = _ref3[1];

      var query;

      if (this.queries[queryHash]) {
        query = this.queries[queryHash];
        query.updateConfig(config);
      }

      if (!query) {
        query = new Query({
          queryCache: this,
          queryKey: queryKey,
          queryHash: queryHash,
          config: config,
          notifyGlobalListeners: function notifyGlobalListeners(query) {
            _this5.notifyGlobalListeners(query);
          }
        });

        if (!this.config.frozen) {
          this.queries[queryHash] = query;
          this.notifyGlobalListeners(query);
        }
      }

      return query;
    } // Parameter syntax with optional prefetch options
    ;

    // Implementation
    _proto.prefetchQuery = function prefetchQuery() {
      try {
        var _this7 = this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (isObject(args[1]) && (args[1].hasOwnProperty('throwOnError') || args[1].hasOwnProperty('force'))) {
          args[3] = args[1];
          args[1] = undefined;
          args[2] = undefined;
        }

        var _getQueryArgs = getQueryArgs(args),
            _queryKey2 = _getQueryArgs[0],
            _config2 = _getQueryArgs[1],
            _options = _getQueryArgs[2]; // https://github.com/tannerlinsley/react-query/issues/652


        var configWithoutRetry = _extends({
          retry: false
        }, _config2);

        var _query;

        return _finallyRethrows(function () {
          return _catch$2(function () {
            _query = _this7.buildQuery(_queryKey2, configWithoutRetry);
            return _invoke$1(function () {
              if ((_options == null ? void 0 : _options.force) || _query.state.isStale) {
                return _awaitIgnored$1(_query.fetch());
              }
            }, function () {
              return _query.state.data;
            });
          }, function (error) {
            if (_options == null ? void 0 : _options.throwOnError) {
              throw error;
            }
          });
        }, function (_wasThrown, _result2) {
          if (_query) {
            // When prefetching, no observer is tied to the query,
            // so to avoid immediate garbage collection of the still
            // empty query, we wait with activating timeouts until
            // the prefetch is done
            _query.activateTimeouts();
          }

          return _rethrow(_wasThrown, _result2);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.setQueryData = function setQueryData(queryKey, updater, config) {
      var query = this.getQuery(queryKey);

      if (query) {
        query.setData(updater);
        return;
      }

      var newQuery = this.buildQuery(queryKey, _extends({
        initialStale: typeof (config == null ? void 0 : config.staleTime) === 'undefined',
        initialData: functionalUpdate(updater, undefined)
      }, config));
      newQuery.activateTimeouts();
    };

    return QueryCache;
  }();
  var defaultQueryCache = makeQueryCache({
    frozen: isServer
  });
  var queryCaches = [defaultQueryCache];
  function makeQueryCache(config) {
    return new QueryCache(config);
  }
  function onVisibilityOrOnlineChange(isOnlineChange) {
    if (isDocumentVisible() && isOnline()) {
      queryCaches.forEach(function (queryCache) {
        queryCache.getQueries(function (query) {
          if (isOnlineChange) {
            query.onOnline();
          } else {
            query.onWindowFocus();
          }
        });
      });
    }
  }

  var setFocusHandler = createSetHandler(function () {
    return onVisibilityOrOnlineChange(false);
  });
  setFocusHandler(function (handleFocus) {
    var _window;

    if (isServer || !((_window = window) == null ? void 0 : _window.addEventListener)) {
      return;
    } // Listen to visibillitychange and focus


    window.addEventListener('visibilitychange', handleFocus, false);
    window.addEventListener('focus', handleFocus, false);
    return function () {
      // Be sure to unsubscribe if a new handler is set
      window.removeEventListener('visibilitychange', handleFocus);
      window.removeEventListener('focus', handleFocus);
    };
  });

  var setOnlineHandler = createSetHandler(function () {
    return onVisibilityOrOnlineChange(true);
  });
  setOnlineHandler(function (handleOnline) {
    var _window;

    if (isServer || !((_window = window) == null ? void 0 : _window.addEventListener)) {
      return;
    } // Listen to online


    window.addEventListener('online', handleOnline, false);
    return function () {
      // Be sure to unsubscribe if a new handler is set
      window.removeEventListener('online', handleOnline);
    };
  });

  var queryCacheContext = React.createContext(defaultQueryCache);
  var useQueryCache = function useQueryCache() {
    return React.useContext(queryCacheContext);
  };
  var ReactQueryCacheProvider = function ReactQueryCacheProvider(_ref) {
    var queryCache = _ref.queryCache,
        children = _ref.children;
    var resolvedQueryCache = React.useMemo(function () {
      return queryCache || makeQueryCache();
    }, [queryCache]);
    React.useEffect(function () {
      queryCaches.push(resolvedQueryCache);
      return function () {
        // remove the cache from the active list
        var i = queryCaches.indexOf(resolvedQueryCache);

        if (i > -1) {
          queryCaches.splice(i, 1);
        } // if the resolvedQueryCache was created by us, we need to tear it down


        if (queryCache == null) {
          resolvedQueryCache.clear({
            notify: false
          });
        }
      };
    }, [resolvedQueryCache, queryCache]);
    return /*#__PURE__*/React.createElement(queryCacheContext.Provider, {
      value: resolvedQueryCache
    }, children);
  };

  var configContext = React.createContext(undefined);
  function useContextConfig() {
    return React.useContext(configContext);
  }
  var ReactQueryConfigProvider = function ReactQueryConfigProvider(_ref) {
    var config = _ref.config,
        children = _ref.children;
    var parentConfig = useContextConfig();
    var mergedConfig = React.useMemo(function () {
      return parentConfig ? mergeReactQueryConfigs(parentConfig, config) : config;
    }, [config, parentConfig]);
    return /*#__PURE__*/React.createElement(configContext.Provider, {
      value: mergedConfig
    }, children);
  };

  function useGetLatest(obj) {
    var ref = React.useRef(obj);
    ref.current = obj;
    return React.useCallback(function () {
      return ref.current;
    }, []);
  }

  function useIsMounted() {
    var mountedRef = React.useRef(false);
    var isMounted = React.useCallback(function () {
      return mountedRef.current;
    }, []);
    React[isServer ? 'useEffect' : 'useLayoutEffect'](function () {
      mountedRef.current = true;
      return function () {
        mountedRef.current = false;
      };
    }, []);
    return isMounted;
  }

  function useMountedCallback(callback) {
    var isMounted = useIsMounted();
    return React.useCallback(function () {
      if (isMounted()) {
        return callback.apply(void 0, arguments);
      }
    }, [callback, isMounted]);
  }
  /**
   * This hook is a safe useState version which schedules state updates in microtasks
   * to prevent updating a component state while React is rendering different components
   * or when the component is not mounted anymore.
   */

  function useSafeState(initialState) {
    var isMounted = useIsMounted();

    var _React$useState = React.useState(initialState),
        state = _React$useState[0],
        setState = _React$useState[1];

    var safeSetState = React.useCallback(function (value) {
      scheduleMicrotask(function () {
        if (isMounted()) {
          setState(value);
        }
      });
    }, [isMounted]);
    return [state, safeSetState];
  }
  function useRerenderer() {
    var _useSafeState = useSafeState({}),
        setState = _useSafeState[1];

    return React.useCallback(function () {
      return setState({});
    }, [setState]);
  }
  /**
   * Schedules a microtask.
   * This can be useful to schedule state updates after rendering.
   */

  function scheduleMicrotask(callback) {
    Promise.resolve().then(callback).catch(function (error) {
      return setTimeout(function () {
        throw error;
      });
    });
  }

  function useIsFetching() {
    var queryCache = useQueryCache();

    var _useSafeState = useSafeState(queryCache.isFetching),
        isFetching = _useSafeState[0],
        setIsFetching = _useSafeState[1];

    React.useEffect(function () {
      return queryCache.subscribe(function () {
        setIsFetching(queryCache.isFetching);
      });
    }, [queryCache, setIsFetching]);
    return isFetching;
  }

  function useDefaultedMutationConfig(config) {
    var contextConfig = useContextConfig();
    var contextQueryCache = useQueryCache();
    var queryCache = (config == null ? void 0 : config.queryCache) || contextQueryCache;
    var queryCacheConfig = queryCache.getDefaultConfig();
    return getDefaultedMutationConfig(queryCacheConfig, contextConfig, config, {
      queryCache: queryCache
    });
  }

  function _await$2(value, then, direct) {
    if (direct) {
      return then ? then(value) : value;
    }

    if (!value || !value.then) {
      value = Promise.resolve(value);
    }

    return then ? value.then(then) : value;
  }

  var ActionType$1;

  function _catch$3(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  }

  function _async$1(f) {
    return function () {
      for (var args = [], i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      try {
        return Promise.resolve(f.apply(this, args));
      } catch (e) {
        return Promise.reject(e);
      }
    };
  }

  (function (ActionType) {
    ActionType["Reset"] = "Reset";
    ActionType["Loading"] = "Loading";
    ActionType["Resolve"] = "Resolve";
    ActionType["Reject"] = "Reject";
  })(ActionType$1 || (ActionType$1 = {}));

  // HOOK
  var getDefaultState$1 = function getDefaultState() {
    return _extends({}, getStatusProps(exports.QueryStatus.Idle), {
      data: undefined,
      error: null
    });
  };

  function mutationReducer(state, action) {
    switch (action.type) {
      case ActionType$1.Reset:
        return getDefaultState$1();

      case ActionType$1.Loading:
        return _extends({}, getStatusProps(exports.QueryStatus.Loading), {
          data: undefined,
          error: null
        });

      case ActionType$1.Resolve:
        return _extends({}, getStatusProps(exports.QueryStatus.Success), {
          data: action.data,
          error: null
        });

      case ActionType$1.Reject:
        return _extends({}, getStatusProps(exports.QueryStatus.Error), {
          data: undefined,
          error: action.error
        });

      default:
        return state;
    }
  }

  function useMutation(mutationFn, config) {
    if (config === void 0) {
      config = {};
    }

    config = useDefaultedMutationConfig(config);
    var getConfig = useGetLatest(config);

    var _React$useReducer = React.useReducer(mutationReducer, null, getDefaultState$1),
        state = _React$useReducer[0],
        unsafeDispatch = _React$useReducer[1];

    var dispatch = useMountedCallback(unsafeDispatch);
    var getMutationFn = useGetLatest(mutationFn);
    var latestMutationRef = React.useRef();
    var mutate = React.useCallback(_async$1(function (variables, mutateConfig) {
      if (mutateConfig === void 0) {
        mutateConfig = {};
      }

      var config = getConfig();
      var mutationId = uid();
      latestMutationRef.current = mutationId;

      var isLatest = function isLatest() {
        return latestMutationRef.current === mutationId;
      };

      var snapshotValue;
      return _catch$3(function () {
        dispatch({
          type: ActionType$1.Loading
        });
        return _await$2(config.onMutate == null ? void 0 : config.onMutate(variables), function (_config$onMutate) {
          snapshotValue = _config$onMutate;
          return _await$2(getMutationFn()(variables), function (data) {
            if (isLatest()) {
              dispatch({
                type: ActionType$1.Resolve,
                data: data
              });
            }

            return _await$2(config.onSuccess == null ? void 0 : config.onSuccess(data, variables), function () {
              return _await$2(mutateConfig.onSuccess == null ? void 0 : mutateConfig.onSuccess(data, variables), function () {
                return _await$2(config.onSettled == null ? void 0 : config.onSettled(data, null, variables), function () {
                  return _await$2(mutateConfig.onSettled == null ? void 0 : mutateConfig.onSettled(data, null, variables), function () {
                    return data;
                  });
                });
              });
            });
          });
        });
      }, function (error) {
        Console.error(error);
        return _await$2(config.onError == null ? void 0 : config.onError(error, variables, snapshotValue), function () {
          return _await$2(mutateConfig.onError == null ? void 0 : mutateConfig.onError(error, variables, snapshotValue), function () {
            return _await$2(config.onSettled == null ? void 0 : config.onSettled(undefined, error, variables, snapshotValue), function () {
              return _await$2(mutateConfig.onSettled == null ? void 0 : mutateConfig.onSettled(undefined, error, variables, snapshotValue), function () {
                var _mutateConfig$throwOn;

                if (isLatest()) {
                  dispatch({
                    type: ActionType$1.Reject,
                    error: error
                  });
                }

                if ((_mutateConfig$throwOn = mutateConfig.throwOnError) != null ? _mutateConfig$throwOn : config.throwOnError) {
                  throw error;
                }
              });
            });
          });
        });
      });
    }), [dispatch, getConfig, getMutationFn]);
    var reset = React.useCallback(function () {
      dispatch({
        type: ActionType$1.Reset
      });
    }, [dispatch]);
    React.useEffect(function () {
      var _getConfig = getConfig(),
          suspense = _getConfig.suspense,
          useErrorBoundary = _getConfig.useErrorBoundary;

      if ((useErrorBoundary != null ? useErrorBoundary : suspense) && state.error) {
        throw state.error;
      }
    }, [getConfig, state.error]);
    return [mutate, _extends({}, state, {
      reset: reset
    })];
  }

  function useDefaultedQueryConfig(config) {
    var contextConfig = useContextConfig();
    var contextQueryCache = useQueryCache();
    var queryCache = (config == null ? void 0 : config.queryCache) || contextQueryCache;
    var queryCacheConfig = queryCache.getDefaultConfig();
    return getDefaultedQueryConfig(queryCacheConfig, contextConfig, config, {
      queryCache: queryCache
    });
  }

  function useBaseQuery(config) {
    if (config === void 0) {
      config = {};
    }

    config = useDefaultedQueryConfig(config); // Make a rerender function

    var rerender = useRerenderer(); // Create query observer

    var observerRef = React.useRef();
    var firstRender = !observerRef.current;
    var observer = observerRef.current || new QueryObserver(config);
    observerRef.current = observer; // Subscribe to the observer

    React.useEffect(function () {
      return observer.subscribe(function () {
        rerender();
      });
    }, [observer, rerender]); // Update config

    if (!firstRender) {
      observer.updateConfig(config);
    }

    var result = observer.getCurrentResult(); // Handle suspense

    if (config.suspense || config.useErrorBoundary) {
      if (result.isError && result.query.state.throwInErrorBoundary) {
        throw result.error;
      }

      if (config.enabled && config.suspense && !result.isSuccess) {
        var unsubscribe = observer.subscribe();
        throw observer.fetch().finally(unsubscribe);
      }
    }

    return result;
  }

  // Implementation
  function useQuery() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var config = getQueryArgs(args)[1];
    return useBaseQuery(config);
  }

  // as the query key changes, we keep the results from the
  // last query and use them as placeholder data in the next one
  // We DON'T use it as initial data though. That's important
  // TYPES

  // Implementation
  function usePaginatedQuery() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var config = getQueryArgs(args)[1];
    var result = useBaseQuery(_extends({}, config, {
      keepPreviousData: true
    }));
    return _extends({}, result, {
      resolvedData: result.data,
      latestData: result.query.state.data === result.data ? result.data : undefined
    });
  }

  // Implementation
  function useInfiniteQuery() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var config = getQueryArgs(args)[1];
    return useBaseQuery(_extends({}, config, {
      infinite: true
    }));
  }

  exports.CancelledError = CancelledError;
  exports.ReactQueryCacheProvider = ReactQueryCacheProvider;
  exports.ReactQueryConfigProvider = ReactQueryConfigProvider;
  exports.isCancelledError = isCancelledError;
  exports.isError = isError;
  exports.makeQueryCache = makeQueryCache;
  exports.queryCache = defaultQueryCache;
  exports.queryCaches = queryCaches;
  exports.setConsole = setConsole;
  exports.setFocusHandler = setFocusHandler;
  exports.setOnlineHandler = setOnlineHandler;
  exports.useInfiniteQuery = useInfiniteQuery;
  exports.useIsFetching = useIsFetching;
  exports.useMutation = useMutation;
  exports.usePaginatedQuery = usePaginatedQuery;
  exports.useQuery = useQuery;
  exports.useQueryCache = useQueryCache;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=react-query.development.js.map
