import { Updater } from './utils';
import { ArrayQueryKey, IsFetchingMoreValue, QueryConfig, QueryStatus } from './types';
import { QueryCache } from './queryCache';
import { QueryObserver, UpdateListener } from './queryObserver';
interface QueryInitConfig<TResult, TError> {
    queryCache: QueryCache;
    queryKey: ArrayQueryKey;
    queryHash: string;
    config: QueryConfig<TResult, TError>;
    notifyGlobalListeners: (query: Query<TResult, TError>) => void;
}
export interface QueryState<TResult, TError> {
    canFetchMore?: boolean;
    data?: TResult;
    error: TError | null;
    failureCount: number;
    isError: boolean;
    isFetched: boolean;
    isFetching: boolean;
    isFetchingMore: IsFetchingMoreValue;
    isIdle: boolean;
    isLoading: boolean;
    isStale: boolean;
    isSuccess: boolean;
    status: QueryStatus;
    throwInErrorBoundary?: boolean;
    updatedAt: number;
}
interface FetchOptions {
    fetchMore?: FetchMoreOptions;
}
export interface FetchMoreOptions {
    fetchMoreVariable?: unknown;
    previous: boolean;
}
export interface RefetchOptions {
    throwOnError?: boolean;
}
export declare enum ActionType {
    Failed = "Failed",
    MarkStale = "MarkStale",
    Fetch = "Fetch",
    Success = "Success",
    Error = "Error"
}
interface FailedAction {
    type: ActionType.Failed;
}
interface MarkStaleAction {
    type: ActionType.MarkStale;
}
interface FetchAction {
    type: ActionType.Fetch;
    isFetchingMore?: IsFetchingMoreValue;
}
interface SuccessAction<TResult> {
    type: ActionType.Success;
    data: TResult | undefined;
    canFetchMore?: boolean;
    isStale: boolean;
}
interface ErrorAction<TError> {
    type: ActionType.Error;
    error: TError;
}
export declare type Action<TResult, TError> = ErrorAction<TError> | FailedAction | FetchAction | MarkStaleAction | SuccessAction<TResult>;
export declare class Query<TResult, TError> {
    queryKey: ArrayQueryKey;
    queryHash: string;
    config: QueryConfig<TResult, TError>;
    observers: QueryObserver<TResult, TError>[];
    state: QueryState<TResult, TError>;
    private queryCache;
    private promise?;
    private cacheTimeout?;
    private staleTimeout?;
    private cancelFetch?;
    private continueFetch?;
    private isTransportCancelable?;
    private notifyGlobalListeners;
    private enableTimeouts;
    constructor(init: QueryInitConfig<TResult, TError>);
    activateTimeouts(): void;
    updateConfig(config: QueryConfig<TResult, TError>): void;
    private dispatch;
    private rescheduleStaleTimeout;
    invalidate(): void;
    private rescheduleGarbageCollection;
    refetch(options?: RefetchOptions): Promise<TResult | undefined>;
    cancel(): void;
    private continue;
    private clearTimersObservers;
    private clearStaleTimeout;
    private clearCacheTimeout;
    setData(updater: Updater<TResult | undefined, TResult>): void;
    clear(): void;
    isEnabled(): boolean;
    onWindowFocus(): void;
    onOnline(): void;
    subscribe(listener?: UpdateListener<TResult, TError>): QueryObserver<TResult, TError>;
    subscribeObserver(observer: QueryObserver<TResult, TError>): void;
    unsubscribeObserver(observer: QueryObserver<TResult, TError>): void;
    private tryFetchData;
    fetch(options?: FetchOptions): Promise<TResult | undefined>;
    private startFetch;
    private startInfiniteFetch;
    fetchMore(fetchMoreVariable?: unknown, options?: FetchMoreOptions): Promise<TResult | undefined>;
}
export declare function queryReducer<TResult, TError>(state: QueryState<TResult, TError>, action: Action<TResult, TError>): QueryState<TResult, TError>;
export {};
